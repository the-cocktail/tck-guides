[
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/git/configuracion/",
	"title": "Configuración",
	"tags": [],
	"description": "",
	"content": "Antes de ponernos a trabajar con ningún repositorio, debemos de configurar las opciones generales de Git para nuestro flujo de trabajo.\n Configura nombre y correo asociados a los commits:  $ git config --global user.name ‘Nombre’ $ git config --global user.email ‘usuario@dominio.com’   Configuramos las opciones por defecto para pull y merge.  $ git config --global merge.ff false $ git config --global branch.autosetuprebase always  Con merge.ff false, hacemos que todos los merges sean \u0026ndash;no-ff, es decir que siempre se genere un nuevo commit al hacer un merge. Por defecto los commits en Git son fast-forward, es decir, que si no tienen la necesidad crear un nuevo commit dejarán las cabezas de las dos ramas a mergear en el mismo punto, dejando la rama mas limpia, pero la historia menos descriptiva. Nosotros preferimos optar por tener toda la información posible en la historia, así podremos ver de que rama estaba viniendo un commit.\nCon branch.autosetuprebase always forzamos que el comando git pull haga siempre un rebase para actualizar las ramas remotas con las locales. Al tener el merge como no-ff, siempre nos dejaría un commit al hacer pull, y en este caso no aporta nada a la historia global del repositorio.\nNOTA: mucho ojo si ya has empezado a trabajar con Git y activas el autorebase posteriormente. Esta opción añade la opción cundo se crea una rama, por lo que las ramas ya creadas anteriormente no la tendrán. Para añadirla, edita el fichero .git/config del proyecto en cuestion y añade rebase = true en las ramas que no lo tengan. Por ejemplo:\n[branch \u0026quot;master\u0026quot;] remote = origin merge = refs/heads/master rebase = true  "
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/test/proyectos/",
	"title": "Proyectos",
	"tags": [],
	"description": "",
	"content": " Proyectos existentes  Identificar funcionalidades críticas para el negocio, Escribir historias de usuario de esas funcionalidades, Implementar los tests de integración de las historias de usuario.  En un proyecto que ya está funcionando y en el que por tanto no vamos a hacer TDD, el objetivo es añadir tests de integración para funcionalidades críticas y así evitar regresiones.\nIdealmente es el cliente o en su defecto el Product Owner quien debe identificar dichas funcionalidades y escribir historias de usuario que el equipo de desarrollo se encargará de implementar como especificaciones ejecutables en forma de tests de integración.\nUna vez identificadas y escritas las historias de usuario en formato Gherkin, debe implementarse el código que interactúa con la aplicación (Steps). Para ello podemos valernos de librerías como Cucumber o Spinach (ruby) o Behat (PHP).\nIdealmente, en este último paso deberíamos seguir las prácticas recomendadas más abajo.\nEstos tests simplemente deben replicar lo que el usuario haría: pinchar en enlaces y botones, rellenar formularios, etc. para después comprobar que el estado de la aplicación y de la interfaz es el que se espera.\nNo es un escenario ideal porque al estar ya en funcionamiento la aplicación todos los participantes en el proyecto van a estar condicionados a la hora de escribir las historias y los tests (en contraposición a TDD).\nNuevos proyectos En un proyecto nuevo el objetivo es hacer TDD. Los pasos a seguir en realidad son los mismos que en un proyecto existente, con la diferencia de que los tests de integración han de estar escritos antes de hacerlos pasar.\nEs un escenario ideal en el que los tests de integración son aún más si cabe especificaciones ejecutables y que además permite recopilar las historias de usuario de una forma más eficiente mediante metodologías como Event Storming.\n"
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/test/glosario/",
	"title": "Glosario",
	"tags": [],
	"description": "",
	"content": " Cobertura Es una métrica que indica qué porcentaje del código de la aplicación está siendo probado por los tests. Hay que tener cuidado con ella porque puede generar una falsa sensación de seguridad: una cobertura alta no es sinónimo ni de robustez del código ni de calidad de los tests, pero al mismo tiempo probablemente no queremos que haya una cobertura baja.\nNo obstante, hay que tener en cuenta que en el testing no se trata de llegar al 100% de cobertura. Se trata de testear de forma adecuada cada parte de la aplicación. Las funcionalidades críticas mediante tests de integración, los casos extremos con tests unitarios, etc. y siempre bajo el criterio de quien desarrolle la aplicación. ¿Merece la pena testear una vista en un test unitario? Normalmente no, pero depende del caso. En el fondo es una cuestión de retorno de inversión.\nMantenibilidad En el contexto del testing, que los tests estén desacoplados del código se traduce en una mayor mantenibilidad de los mismos. En el caso de los tests de integración es fácil conseguir esto si se siguen buenas prácticas.\nHistoria de usuario Es una representación por escrito de un requisito de la aplicación contada desde el punto de vista del usuario. Es importante que esté expresada en términos del cliente y jamás debe incorporar jerga técnica (a no ser que el negocio del cliente tenga que ver con asuntos técnicos, obviamente).\nEs muy habitual el formato Gherkin, con la estructura Given-When-Then.\nStep Es cada una de las líneas que componen una historia de usuario:\nDado un usuario registrado Si visita la home Entonces ve un mensaje de bienvenida  Ejemplo:\nstep \u0026quot;visita la home\u0026quot; do visit home_path end step \u0026quot;ve un mensaje de bienvenida\u0026quot; do expect(page).to have_text(\u0026quot;¡Hola!\u0026quot;) end  Estos Steps deben implementarse siguiendo buenas prácticas.\nTDD Test-driven development. Metodología de desarrollo que requiere que los tests se escriban antes de la funcionalidad.\nIncluso en el caso de proyectos que ya están funcionando, puede (y debe) hacerse TDD a la hora de solucionar regresiones.\nTest de integración A diferencia de los tests unitarios, los test de integración prueban todo el stack interactuando con la aplicación como si de un usuario final se tratase. Son por tanto ideales para asegurar el correcto funcionamiento de funcionalidades críticas para el negocio.\nSu mayor pega es que son lentos, y sus ventajas es que son fáciles de escribir, no requieren mayor conocimiento del código de la aplicación si se evita el acoplamiento en los steps, que además conlleva un incremento de su mantenibilidad.\nTest funcional Se utilizan para testear parte de la aplicación sin llegar a levantar todo el stack, pero implicando varias clases o funciones. Queda a criterio de la persona que los implemente saber cuándo y por qué es necesario un test funcional y no varios unitarios o uno de integración.\nUn caso típico sería una test de una clase pero que necesita interactuar con la base de datos (y por tanto tiene como mínimo una dependencia en el ORM y en la propia base de datos).\nTest unitario Pruebas de código que verifican el funcionamiento de clases/métodos/funciones de forma aislada, sin dependencias. Tienen la ventaja de que se ejecutan mucho más rápido que los tests funcionales o los de integración.\n Ayudan a diseñar buen código.  Si una clase o una función es difícil de testear es que está mal diseñada o tiene demasiadas responsabilidades. Para obtener el mayor beneficio de este punto lo ideal es hacer TDD.  Son ideales para testear casos extremos de forma rápida.  Por ejemplo, un sistema de descuentos en el que haya que probar que se aplican correctamente según diferentes criterios, a saber: compra mínima, peso del pedido, productos que ya tienen descuento, etc. Probar todos los casos con tests de integración sería demasiado lento.  Son ideales para reproducir bugs y evitar regresiones sin falta de tener que levantar todo el stack en un test de integración para el mismo cometido. Similar al punto 3, pueden usarse para testear casos erróneos.  Otra vez, usar tests de integración para probar cada caso en el que puede aparecer un error en pantalla es excesivo e ineficiente.   La desventaja de los tests unitarios es que son más difíciles de escribir y de mantener y requieren por tanto más experiencia que los de integración. No resulta siempre fácil que estén desacoplados del código (aunque el acoplamiento suele ser un indicativo de que o bien el test no está bien pensado o el código que se está testeando no está bien diseñado).\nFragilidad Un test frágil es aquel que tiene más probabilidad de fallar debido a cambios en la implementación, incluso aunque el comportamiento no haya cambiado. Esto es, es un test que está acoplado con el código que testea.\nLos tests deben siempre comprobar que el comportamiento de la aplicación es el adecuado, nunca la implementación. En resumen, los tests deben ser pruebas de caja negra.\nEspecificación ejecutable Un test escrito de forma consensuada con el cliente en forma de test de integración. La clave aquí es que la especificación no deja de ser un contrato con el cliente: especifica qué debe hacer la aplicación y evita regresiones.\nRegresión Aparición de un bug en una funcionalidad que hasta ahora funcionaba sin problema. A la hora de solucionar este tipo de bugs, lo que se debe hacer es usar TDD: reproducimos el bug en un test, y lo hacemos pasar.\nProduct Owner Este término proviene de scrum, pero en cualquier proyecto sería el rol desempeñado por la persona que ejerce de interlocutor con el cliente: conoce el proyecto, las necesidades de negocio y sabe priorizar tareas e identificar las funcionalidades críticas.\nRefactorizar Es un proceso que no afecta a la funcionalidad, y que sólo persigue mejorar el diseño del código. En un proyecto sin tests la\n"
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/git/reglas/",
	"title": "Reglas generales",
	"tags": [],
	"description": "",
	"content": " Clientes Recomendamos encarecidamente no usar clientes gráficos hasta no tener un control total de los comandos básicos en consola.\nAntes de usar un cliente gráfico, debemos de investigar qué hacen internamente las acciones. Puede haber clientes que implementen ciertas acciones de forma distinta a la que esperamos, ocasionando situaciones inesperadas.\nRamas  Escribe los nombre en inglés y sólo con letras y números, nada de acentos, ñ\u0026rsquo;s, # o caracteres que puedan dar problemas.\n Usa guiones para separar palabras.\n Usa nombres cortos y descriptivos:\n  # bien $ git checkout -b oauth-migration # poco preciso $ git checkout -b login_fix   Siempre que sea posible, añade el número de ticket:  # Ticket #36500 $ git checkout -b feature/36500--oauth-migration  NOTA: Si no hay número de ticket, es un buen indicador de que debería de haber un ticket, créalo.\n Agrupa las ramas en función del tipo de trabajo, para eso, nombra la rama empezando con el tipo y /, por ejemplo feature/ para nuevas funcionalidades y fix/ para correcciones:  $ git checkout -b feature/oauth-migration $ git checkout -b fix/text-error  NOTA: Mantener la consistencia del proyecto, revisar las agrupaciones que se están usando ya para no crear nuevas.\n Para grandes funcionalidades en las que van a trabajar varias personas, crear una rama específica y crear subcarpetas para las distintas tareas:  # Rama común $ git checkout -b feature-redesign/master # Trabajo de back $ git checkout -b feature-redesign/back # Trabajo de front $ git checkout -b feature-redesign/front   Cuidado con crear múltiples anidaciones ya que puede bloquear ramas. Si existe la rama feature/oauth-migration y se crea la rama feature/oauth-migration/front, la primera será un directorio para Git y no se podrá hacer checkout a ella.\n Borra tus ramas personales en local y del repositorio remoto cuando acabes de trabajar en una tarea y ya esté mergeada a master, a no ser que exista alguna razón para mantenerla. Mantengamos los repositorios limpios, ¿acaso no borras tus ramas en casa?\n  Consejo: Borra siempre las ramas locales desde master con -d, en el caso de no estar mergeadas no te dejará.\n# Borrar la rama local $ git branch -d feature/oauth-migration # Borrar la rama remota $ git push origin :feature/oauth-migration  Puedes listar las ramas mergeadas en master con:\n$ git branch --merged master | grep -v \u0026quot;\\* master\u0026quot;`  Puedes limpiar las ramas remotas que han sido borradas en el repositiorio con:\n$ git remote prune origin  Commits  Cada commit debe englobar el menor cambio \u0026ldquo;lógico\u0026rdquo; posible en vez de juntar múltiples cambios en un solo commit grande.\n Haz commits con lógica cada poco tiempo. Con commits pequeños y atómicos será más fácil entender la historia y revertir cambios si se producen problemas.\n Si has acumulado varios commits, al hacerlo procura mantener el orden lógico, es decir si un cambio en un commit depende de otro, el dependiente deberá de hacerse después. Y describe la dependencia en los comentarios.\n  Mensajes  Escribir mensajes descriptivos y consistentes:  Una primera línea con una descripción concisa de menos de 50 caracteres, para una correcta visualización tanto en clientes como en la consola. Primera palabra en mayúsculas, no acabar en punto la frase (es el asunto del commit) y usar el imperativo de la segunda persona del singular. Por ejemplo, en vez de escribir \u0026ldquo;He añadido comprobaciones para\u0026rdquo; o \u0026ldquo;Añadiendo comprobaciones para\u0026rdquo;, utilizar la frase \u0026ldquo;Añade comprobaciones para\u0026rdquo; Dejar una línea en blanco y escribir una descripción más detallada (por qué, cómo, número de ticket, enlaces\u0026hellip;), máximo 72 caracteres por línea. Dependiendo del cliente lo detectará y lo mostrara como información colapsada junto a la descripción general.   Asunto de menos de 50 carcteres Explicación detallada de lo acontecido en el ticket sin pasar de los 72 caracteres. La línea de separación hará que algunos clientes traten la primera línea como el asunto y esto como el cuerpo. Separar más párrafos con saltos de línea. - También está bien usar bullets. Información sacada de http://git-scm.com/book/es/v1/Git-en-entornos-distribuidos-Contribuyendo-a-un-proyecto   Por esto, es más recomendable usar un editor para escribir los commits que los commits en línea (-m)  Idioma Debemos unificar el idioma a usar en código y mensajes como commits, issues\u0026hellip;\nEstá bien intentar escribirlo todo en inglés para forzarnos y practicar, de echo si trabajásemos en un solo producto parecería el caso ideal, pero en ocasiones puede derivar en comentarios cortos, imprecisos o mal explicados. Para cumplir con el objetivo de comunicar la información de la mejor manera a los compañeros que están o llegan a un proyecto aplicaremos las siguientes reglas:\n Código: todo en inglés (esto es más de unas guías de estilo). En proyectos privados, es decir proyectos internos, todas las explicaciones en comentarios, readme, commits, issues, pull requests\u0026hellip; en español. En proyectos públicos, es decir proyectos para la comunidad, todas las explicaciones en comentarios, readme, commits, issues, pull requests\u0026hellip; en inglés.  "
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/test/buenas-practicas/",
	"title": "Buenas prácticas",
	"tags": [],
	"description": "",
	"content": " Evitar el acoplamiento en los steps Imaginemos que tenemos un step:\n Dado un usuario registrado  Aquí hay dos enfoques diferentes a la hora de implementarlo:\n Interactuar con la aplicación y registrar el usuario, rellenando el formulario de registro, pinchando en el mail de verificación, etc. ruby step \u0026quot;un usuario registrado\u0026quot; do visit home_path fill_in \u0026quot;Username\u0026quot;, with: \u0026quot;JohnDoe\u0026quot; fill_in \u0026quot;Password\u0026quot;, with: \u0026quot;mypass\u0026quot; fill_in \u0026quot;Password confirmation\u0026quot;, with: \u0026quot;mypass\u0026quot; click_button \u0026quot;Sign up\u0026quot; end  Crear el usuario en la base de datos directamente usando el modelo de la aplicación. ruby step \u0026quot;un usuario registrado\u0026quot; do User.create!(username: \u0026quot;JohnDoe\u0026quot;, password: \u0026quot;mypass\u0026quot;) end   Obviamente con el segundo enfoque vamos a ahorrar código y tiempo de ejecución en el test, pero esto tiene un problema y es que el test va a estar acoplado con el código y va a incrementar la fragilidad del test.\nLa ventaja del primer enfoque es que el test va a ser 100% un test de integración y ni siquiera requiere que quien lo desarrolla conozca los detalles de la implementación de lo que significa que un usuario esté registrado, acercándose más por tanto a ser una prueba de caja negra.\nSolucionar regresiones Siempre debe escribirse un test que reproduzca el bug y después debe hacerse pasar (TDD). Es la única manera de asegurarse que el test cubre el problema.\nIdealmente debería usarse un test unitario si es posible, normalmente no merece la pena usar un test de integración.\nCucumber vs. Spinach El buque insignia de los tests de integración siempre ha sido Cucumber. No obstante, su flexibilidad puede inducir a algunos problemas, y por tanto cualquier otra librería que sea un port de Cucumber va a heredarlos:\nLos steps son globales En Spinach los steps están escritos en módulos de ruby normales y corrientes, no son globales y en caso de necesitar reutilizarlos es tan fácil como usar include.\nSoporte para variables y tablas en los steps: Dado /un descuento del (.+) en los productos del tipo (.+)%/ do |discount,type| [...] end  Es muy flexible, pero por motivos de legibilidad y mantenibilidad es mejor ceñirse a frases concretas y directamente no usar variables. (Spinach no soporta variables a propósito).\nEsquema del escenario: comer Dado que hay \u0026lt;start\u0026gt; pepinillos Cuando me como \u0026lt;eat\u0026gt; pepinillos Entonces deberían quedar \u0026lt;left\u0026gt; pepinillos Ejemplos: | start | eat | left | | 12 | 5 | 7 | | 20 | 5 | 15 |  Esta especificación lo que haría sería ejecutar las diferentes permutaciones del escenario según la tabla provista en \u0026ldquo;Ejemplos\u0026rdquo;.\nEs fácil ver por qué alguien querría usar este estilo. Tenemos un test de integración y podemos reutilizarlo para probar casos extremos y cómo estos se solapan. Problema: los tests de integración son lentos. Lo ideal sería probar un caso base desde un test de integración sin variables, y las diferentes permutaciones aquí representadas en la tabla de ejemplos en tests unitarios, que son mucho más rápidos.\nConclusión Aunque se utilice Cucumber u otra librería que tenga soporte para variables y tablas, es mejor ceñirse a steps que no soporten variables. Esto obviamente queda siempre a discreción de quien desarrolle los tests y no es obligatorio, es simplemente una recomendación.\nUna buena explicación de todo esto se puede ver en esta presentación sobre Spinach.\n"
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/git/flujo/",
	"title": "Flujo de trabajo",
	"tags": [],
	"description": "",
	"content": " Por lo general los proyectos tendrán como mínimo dos ramas, master y staging. La rama master es la que usan los servidores de producción para los despliegues, mientras que staging es la de los servidores de prueba.\nHabrá proyectos más sencillos, en los que el concepto de staging no haga falta. En ese caso obviaremos las partes que afecten a staging pero seguiremos aplicando el resto del flujo de la misma forma.\nConsideraciones generales  Nunca hacer commits directos sobre master. Las ramas nuevas siempre saldrán de master, salvo casos especiales como una funcionalidad de largo recorrido con varias tareas. Las ramas nuevas jamás saldrán de staging. Las rama de staging jamás se mergeará sobre otra rama. Salvo casos particulares, las ramas deberían de mergearse primero a staging y tras asegurarnos de que todo funciona, a master o donde corresponda en el proyecto, como por ejemplo integration. Antes de mergear una rama, actualizar la rama sobre la que vamos a mergear para resolver conflictos en nuestra rama. Comprobar que una rama funciona correctamente antes de pushear. No pushear cambios en master que no se puedan desplegar. Para actualizar las ramas podemos usar git pull pero tambíen es recomendable hacer por separado git fetch y git rebase. De esta forma veremos mas claramente que ha cambiado en el repositorio y haremos el rebase con más cuidado. Nunca reescribir la historia ya publicada. Ciertos comandos como el rebase pueden reescribir la historia de los commits. Si esos commits ya estaban publicados, nunca debemos de vovler a publicarlos ya que afectaremos al resto de compañeros que los tengan en su repositorio local. Salvo casos muy particulares y completamente controlados, jamás hacer git push -f.  Flujos de trabajo Dada la gran cantidad de proyectos distintos y clientes con distintas necesidades no podemos tener un flujo común para todos. El encargado de cada proyecto deberá determinar el flujo de trabajo más óptimo según el estado en el que se encuentra el proyecto, por ejemplo un proyecto en mantenimiento con poca carga de trabajo no requerirá el mismo flujo que un proyecto con constantes evolutivos y varias personas con dedicación total.\nEn este apartado describiremos distintos flujos para casos a mínimo y máximos:\nBásico En un flujo básico debemos crear una nueva rama (según las reglas) para cada nueva tarea que vayamos a realizar. Nuestro trabajo de forma particular deberá ir siempre en una rama independiente, nunca trabajaremos directamente sobre una rama con otro usuario.\nUna vel la tarea este realizada procederemos según las reglas básicas, primero merge a staging para probar, finalmente pull request a master y despliegue tras aceptación.\nMáximos Con multiples desarrolladores, multiples funcionalidades y tareas de mantenimiento en paralelo y múltiples revisiones de usuario.\nUsar una rama de desarrollo o integración para unificar todo el código antes de llevarlo a master.\nLas nuevas funcionalidades se van llevando a staging para probar y con pull request a desarrollo o integración.\nTODO: Corregir, la rama siempre debe de salir de master y añadir staging.\nLos fixes urgentes deben salir de master, volver a master (con pull request y tageo tras despliegue) y actualizarse en desarrollo o integración.\nEn casos muy particules en los que un proyecto tenga despliegues de desarrollos muy planificados, puede llevarse una rama de release donde concentrar solo esos desarrollos. Por ejemplo, podría darse el caso de tener una máquina específica para desplegar ese desarrollo de forma aislada del resto para una validación específica del cliente.\nPull requests Haremos siempre pull requests de nuestras ramas a la hora de unificar nuestros cambios con resto del código.\nDado que el objetivo principal de las pull requests es que el resto del equipo haga una revisión del código, deberemos de asegurarnos con el encargado del proyecto de que exista una persona al menos que vaya a poder revisarla. En caso contraro la pull requests pierde el sentido, las pull requests no son un diario de desarrollo.\nConsideraciones generales:\n Las pull requests irán contra las ramas encargadas de la unificación del código master, integration, release\u0026hellip; en cualquier caso nunca contra staging. Las pull requests no son una interfaz gráfica para hacer un merge. Escribir un título descriptivo e indicar el ticket: [Id del ticket] Título del ticket Utilizar etiquetas para identificar el tipo y el estado: WIP, feature\u0026hellip; Asignar los revisores adecuados. Si el proyecto tiene releases planificadas, usar las milestones para saber a cual corresponde. Por ejemplo una milestone con la fecha planificada del despliegue.  Pasos para la revisión:\n Leer con clama la descripción. Probar los cambios en local y ver que funciona como se explica. Revisar el código de los commits. Si aplica, intentar dar feedback constructivo educadamente.  Plantillas Todos los proyectos deben de contener las siguientes plantilla pull requests en una carpeta .github. Si aplica también se puede hacer una para issues.\nPlantilla para pull requests, fichero PULL_REQUEST_TEMPLATE.md:\n[Ticket de referencia](SUSTITUIR_POR_URL_DE_TICKET) ## Resumen Escribir aquí un resumen o listado breve de cosas que añade o cambia esta PR. Utilizar una check list para seguir el progreso. - [X] Tarea 1. - [ ] Tarea 2. - [ ] Tarea 3. ## Pruebas Ejemplos de como probar los cambios: pasos para replicar un problema, snippets de código para ejecutar en consola... ## Despliegue Escribir aquí qué comandos y consideraciones que son necesarios para su despliegue (por ejemplo, borrar caché). Si no hace falta ejecutar nada, se puede borrar esta parte.  Tags Cada vez que se haga un despliegue, crearemos un tag de git con la la fecha del despliegue. Si se hacen varios despliegues el mismo día, los diferenciaremos con un número\n20180101 20180101-2 20180213 20180213-2 20180213-3  De esta formas crearemos puntos de control en el repositorio de todo el código desplegado.\nIndependientemente se podrán llevar tags versionadas como\nHooks [WIP] Añadiremos hooks de ayuda por defecto en nuestros proyectos:\n Validaciones staging (nuevas ramas, merges). Avisos de higiene (borrar ramas ya mergeadas a master). Avisos de mantenimiento (ramas desactualizadas).  Los hooks no deben depender del proyecto, sólo al propio repositorio, por lo tanto hooks que pasen pruebas, formateos y demás que dependan del stack de cada uno, deberan de ser gestionados personalmente.\nEjemplos Ejemplo de flujo de trabajo con una nueva funcionalidad:\n# Nos vamos a master y creamos la rama $ git checkout master $ git checkout -b feature/oauth-migration # Trabajamos, y cuando esté listo lo llevamos a staging y comprobamos $ git checkout staging $ git fetch $ git rebase $ git merge feature/oauth-migration $ git push # Cuando tengamos que desplegar # Este paso se haría realmente con una pull request $ git checkout master $ git fetch $ git rebase $ git merge feature/oauth-migration $ git push # Si hemos acabado con la funcionalidad $ git branch -d feature/oauth-migration # Y si hemos pusheado nuestra rama $ git push origin :feature/oauth-migration  En caso de no poder pushear una rama porque nos olvidamos de actualizar antes de mergear, nos aseguramos de que no perdemos nada en esa rama, actualizamos con fetch y hacemos un reset \u0026ndash;hard al remoto para volver a mergear con la rama actualizada:\n$ git checkout master $ git merge feature/oauth-migration $ git push # ERROR $ git fetch $ git reset --hard origin/master $ git merge feature/oauth-migration $ git push  Manten el repositorio (local y remoto) limpo, ejecuta comandos de mantenimiento cada cierto tiempo::\n git-gc(1) git-prune(1) git-fsck(1)  La policía de git La policía de git no tendrá piedad con:\n Crear una rama desde staging. Mergear staging sobre otra rama. Hacer rebase en una rama ya publicada. Forzar un push (-f).   LA HE LIADO PARDA, versi\u0026oacute;n PIWEEK de Kaleidos from kaleidos on Vimeo.\n"
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/git/casos-reales/",
	"title": "Casos reales",
	"tags": [],
	"description": "",
	"content": " Describimos aquí una serie de casos \u0026ldquo;reales\u0026rdquo; (puede que alguno esté dramatizado), como ejemplo de situaciones complicadas que se pueden dar si no si no tenemos cuidado al trabajar con el repositorio.\nRevert de staging Conflicto y forzado Commits en el limbo 3 meses sin subir "
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/docker/",
	"title": "Docker",
	"tags": [],
	"description": "",
	"content": " Guía de referencia de Docker Guía de uso de docker para desarrollo.\n"
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/git/",
	"title": "Git",
	"tags": [],
	"description": "",
	"content": " Guía de referencia de Git Esta guía establece la configuración requerida del git, las reglas generales sobre el uso de los repositorios, y la descripción de los distintos flujos de trabajo a seguir según el tipo de proyecto.\nCréditos Estas guías está basada en nuestro propio uso de Git, las recomendaciones de Git y esta guía.\n"
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/",
	"title": "Guías de referencia TCK",
	"tags": [],
	"description": "",
	"content": " Guías de referencia de The Cocktail Esta página reune las distintas guías a seguir en cada proyecto sobre distintos temas como flujo de trabajo de Git, metodología de testing o entornos de desarrollo con Docker.\n"
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://gu%C3%ADas.the-cocktail.com/test/",
	"title": "Testing",
	"tags": [],
	"description": "",
	"content": " Guía de referencia de Testing y buenas prácticas La presente documentación pretende establecer un protocolo para la implantación de testing en proyectos existentes o en nuevos proyectos.\nExiste un glosario así como un compendio de buenas prácticas que se consideran vitales para conseguir un equilibrio entre la cobertura y la mantenibilidad de los tests.\n"
}]